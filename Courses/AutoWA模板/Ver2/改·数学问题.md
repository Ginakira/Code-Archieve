# 一、数学问题

####1. 精度计算——大数阶乘

```c++
#include<iostream>
using namespace std;
int main()
{
	int n;
	int c[10000];
	c[0] = 1;
	int di = 1;
	cin >> n;
	int num = 0;
	for(int i = 2; i <= n; i++)
	{
		for(int j = 0; j < di; j++)
		{ 
		  num =  c[j] * i + num;
		  c[j] = num % 10;
		  num /= 10;	
		}
		while(num)
		{
			c[di] = num % 10;
			num = num / 10;
			di ++ ;
		}
	}
	for(int i = di - 1; i >= 0; i--)
	{
		cout<<c[i];
	}
	return 0;
}
```

#### 2. 快速幂取模

``` cpp
LL pow(LL a, LL n, LL p)    //快速幂 a^n % p
{
    LL ans = 1;
    while(n)
    {
        if(n & 1) ans = ans * a % p;          //若不取模就去掉p
        a = a * a % p;
        n >>= 1;
    }
    return ans;
}
```

#### 3.模运算

1.取模运算：a % p（a mod p），表示a除以p的余数。
2.模p加法：(a + b) % p = (a%p + b%p) % p
3.模p减法：(a - b) % p = (a%p - b%p) % p
4.模p乘法：(a * b) % p = ((a % p)*(b % p)) % p
5.幂模p ： (a^b) % p = ((a % p)^b) % p
6.模运算满足结合律、交换律和分配律。

#### 4. 欧拉函数

欧拉函数，一般记为 ϕ(n)，表示小于等于 n 的数中与 n 互质的数的个数。

​     求 n  以内与 n 互质数的个数

``` c++
int primes[N], euler[N], cnt;
bool st[N];

// 质数存在primes[]中，euler[i] 表示
// i的欧拉函数
void get_eulers(int n)
{
    euler[1] = 1;
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i])
        {
            primes[cnt ++ ] = i;
            euler[i] = i - 1;
        }
        for (int j = 0; j < cnt && i * primes[j] <= n; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0)
            {
                euler[i * primes[j]] = euler[i] * primes[j];
                break;
            }
            euler[i * primes[j]] = euler[i] * (primes[j] - 1);
        }
    }
}
```

#### 5.扩展欧几里得算法

裴蜀定理：若 a,b 是整数,且 (a,b)=d，那么对于任意的整数 x,y,ax+by都一定是 d的倍数，特别地，一定存在整数x,y，使 ax+by=d 成立。扩展欧几里得算法可以在O(logn) 的时间复杂度内求出系数 x,y。

```c++
int exgcd(int a, int b, int &x, int &y)
{
    if (!b)
    {
        x = 1; y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= (a/b) * x;
    return d;
}
```

#### 6.线性筛素数

``` c++
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; j < cnt && i * primes[j] <= n; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}
```

#### 7.数论简单小结论

- 根据费马小定理推得：a^x % p = a^(x%(p-1) ) % p

#### 8.快速读入

``` cpp
#include<iostream>

using namespace std;

//关闭流同步 ios_base::sync_with_stdio(false)
inline int read() {
	int x = 0, f = 1;
	char c = getchar();
	while(c < '0' || c > '9') {
		if(c == '-') f = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9') {
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * f;
}
int main(){
	int a;
	a = read();
	cout<<a;
	return 0;
}

```

