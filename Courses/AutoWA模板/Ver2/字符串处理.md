# 二、字符串处理

## 1.字符串标准库

### C标准库（针对字符数组）

**`int strlen(const char *str)`** ：返回从 `str[0]` 开始直到 `'\0'` 的字符数。

**`sscanf(const char *__source, const char *__format, ...)`** ：从字符串 `__source` 里读取变量，比如 `sscanf(str,"%d",&a)` 。

**`sprintf(char *__stream, const char *__format, ...)` **：将 `__format` 字符串里的内容输出到 `__stream` 中，比如 `sprintf(str,"%d",i)` 。

**`int strcmp(const char *str1, const char *str2)`** ：按照字典序比较 `str1 str2` 若 `str1` 字典序小返回负值，一样返回 0，大返回正值 请注意，不要简单的认为只有 `0, 1, -1` 三种，在不同平台下的返回值都遵循正负，但并非都是 `0, 1, -1`

**`char *strcpy(char *str, const char *src)` **: 把 `src` 中的字符复制到 `str` 中， `str` `src` 均为字符数组头指针，返回值为 `str` 包含空终止符号 `'\0'` 。

**`char *strcat(char *str1, const char *str2)` **: 将 `str2` 接到 `str1` 的结尾，用 `*str2` 替换 `str1` 末尾的 `'\0'` 返回 `str1` 。

### C++标准库（针对字符串，兼容字符数组）

**std::string**  头文件string

- 访问运算符 `s[cur]` 返回 `cur` 位置的字符（引用）。
- 访问函数 `data()/c_str()` 返回一个 `const char*` 指针，内容与该 `string` 相同。
- 容量函数 `s.size()` 返回字符串长度。
- 判空函数`s.empty()` 返回字符串是否为空（布尔型）
- `s.resize(int len,char c)` 把字符串当前大小置为len，并用字符c填充不足的部分
- `s.copy(char *s, int n, int pos = 0) const` 把当前串中以pos开始的n个字符拷贝到以s为起始位置的字符数组中，返回实际拷贝的数目
- `getline(cin, st1)` 读取字符直到换行，单纯的cin遇到空格停止
- `getline(cin, st1, 'a')` 一个直到‘a’结束，其中任何字符包括'\n'都能够读入
- `st1.length()`  返回字符个数
- `st1 + st2` `st1 = st2` 可直接连接、替换
- `tolower(c)` `toupper(c)` 大小写转换（字符）
- `s.substr(i, j) `  截取s串中从i开始长度为j的子串
- `s.insert(it, p)  `把字符串p插入到it的位置
- `s.erase(3) ` `s.earse(0, 4)`  删除对应下标开始对应个数的元素
- `s.compare("good")`   s与”good“比较相等返回0，比"good"大返回1，小则返回-1（字典序）
- `s.reverse(s.begin(), s.end())`  字符串反转
- `s.swap(string &s2)` 交换当前字符串与s2的值

## 2.字符串替换/插入

### 替换函数

`s.replace(int p0, int n0, const char *s2)` 删除从p0开始的n0个字符，然后在p0处插入串s2

`s.replace(int p0, int n0,const string &s2, int pos, int n)` 删除p0开始的n0个字符，然后在p0处插入串s2中从pos开始的n个字符

`s.replace(int p0, int n0,int n, char c)` 删除p0开始的n0个字符，然后在p0处插入n个字符c

### 插入函数

`s.insert(int p0, const char *s2)` 在p0位置插入字符串s

`s.insert(int p0,const string &s2, int pos, int n)` 在p0位置插入字符串s中pos开始的前n个字符

`s.insert(int p0, int n, char c)` 此函数在p0处插入n个字符c

### 整体替换

使用STL的replace函数实现，结果是母串中所有相同的都被替换

用法：`string_replace(要替换的母串, 要替换掉的子串, 用来替换的字符串)`

如：`string_replace(st1, "Winter", "AutoWA")` 把st1中的winter换成AutoWA

```c++
void string_replace(string & strBig, const string & strsrc, const string &strdst) {
        size_t pos=0;
        size_t srclen=strsrc.size();
        size_t dstlen=strdst.size();
        while( (pos=strBig.find(strsrc, pos)) != string::npos){
                strBig.replace(pos, srclen, strdst);
                pos += dstlen;
        }
}
```

## 3.字符串查找

查找函数`find()`找到并返回某字符的位置

- `st1.find('a')`输出第一个‘a'的下标（0开始），查找对象可以也是一个字符串

- `st1.find('a', 3)`从下标3开始查询a的下标，返回的下标同上

- `st1.rfind('a', 5)`从0到5从后向前查找a所在该串的位置

- `find()`函数返回的是一个size_t类型（或string::size_type类型）

  当没有匹配到目标的时候，返回的是str.npos

  例：定义一个size_t类型变量，可判断是否匹配到了

  ```c++
  size_t position;
  string s = "AutoWA";
  position = s.find("WA");
  cout << position << endl;  //输出4
  position = s.find("ACM");
  if(position == s.npos) cout << "None" << endl;  //未匹配到，输出None
  ```

- `st1.find_first_of(st2, 0)` 在str1中从0开始向后查找，只要在st1中遇到一个字符与st2中任意一个字符相同，就返回该字符在st1中的位置，匹配失败返回npos

- `st1.find_last_of(st2, 4)` 同上，从指定位置向前查找

- `st1.find_first_not_of(st2, 0)` 同上，遇到一个字符与st2中任何一个不同，返回位置，last同理。

## 4.最长公共子序列（LCS）

给定两个字符串 str1 和 str2 ，如果将 str1 去掉一些字符后得到字符串str，将str2去掉一些字符后也能得到字符串 str ，则 str 是 str1 和 str2 的一个公共子串。在得到str的时候不能改变字符的相对顺序。求字符串 str 长度的最大值。

如 ABCEF BMCGUAFB，则最长公共子序列为3: BCF

```c++
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;    
int dp[5005][5005];
    char a[5005],b[5005];
int main()
{
 
    cin>>a+1>>b+1;
    int n=strlen(a+1);
    int m=strlen(b+1);
    for(int i=1;i<=n;++i)
    for(int j=1;j<=m;++j)
    {
        if(a[i]==b[j])dp[i][j]=dp[i-1][j-1]+1;
        else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
    }
    cout<<dp[n][m];
}
```

 