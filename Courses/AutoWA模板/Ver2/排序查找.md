# 三、排序/查找

## 1.快速排序  一般较快-取决于元素排列顺序

说明：quickSort(数组名，起始元素下标， 终止元素下标 )，默认升序排列

```c++
void quickSort(int *arr, int left, int right){
    int i = left, j = right;
    int mid = arr[(i+j)/2];
    while(i <= j){
        while(arr[i] < mid) i ++;
        while(arr[j] > mid) j --;
        if(i <= j){
            int tmp;
            tmp = arr[i]; 
			arr[i] = arr[j]; 
			arr[j] = tmp;
            i ++;
			j --;
        }
    }
    if(i < right) quickSort(arr,i, right);
    if(left < j) quickSort(arr,left, j);
}
```



## 2.归并排序 稳定-时间复杂度固定

用法同上

```c++
int temp[max];
void merge(int *a, int left, int mid, int right) {
	int i = left, j = mid + 1, n = 0, length = right - left;
	while(i <= mid && j <= right) {
		if(a[i] < a[j]) {
			temp[n++] = a[i++];
		} else {
			temp[n++] = a[j++];
		}
	}
	if(i > mid) {
		while(j <= right) {
			temp[n++] = a[j++];
		}
	} else {
		while(i <= mid) {
			temp[n++] = a[i++];
		}
	}
	for(int k = 0;k <= length;++k) {
		a[left+k] = temp[k];
	}
}
void mergesort(int *a, int left, int right) {
	if(left < right) {
		int mid = (left + right) / 2;
		mergesort(a,left,mid);
		mergesort(a,mid+1,right);
		merge(a,left,mid,right);
	}
}
```

## 3.二分查找

说明：*arr为数组名， begin为起始下标，end为终止下标， e为要查找的内容，最终返回查找的内容的下标，如果没有找到则返回比它小的第一个数的下标

**数组必须已经按照升序排列好**

```c++
int bSearch(int *arr, int begin, int end, int e) {
    int mid, left = begin, right = end;
    while(left <= right) {
        mid = (left + right) >> 1;
        if(arr[mid] > e) right = mid - 1;
        else left = mid + 1;
    }
    return right;  
}
```

## 4.STL排序

头文件依赖：`<algorithm>`

`sort(begin, end, cmp)`  **<font size=4>范围是左闭右开</font>**

begin数组首地址，end数组尾地址，cmp自定义比较规则，默认为升序排序。

降序排列`sort(begin, end, greater<int>())`

或自定义比较方法

```c+
bool cmp(int a, int b) {
	return a > b;	
}
```

结构体排序自定义cmp：

```c++
bool cmp(T a, T b) {
	return a.time > b.time;	
}
```
