# 一、数学问题

####1. 精度计算——大数阶乘

```c++
#include<iostream>
using namespace std;
#include<cstring>
int main(){
int num[100000]={0};
num[0]=1,num[1]=1;
int n;cin>>n;
int book=0;
for(int i=1;i<=n;i++){
	for(int j=1;j<=num[0];j++){
		num[j]*=i;
	}
	for(int j=1;j<=num[0];j++){
			if(num[j]<10){
			continue;}
			num[j+1]+=num[j]/10;
			num[j]%=10;
			num[0]+=(j==num[0]);
		}
	 }
   for(int i=num[0];i>0;i--){
   	cout<<num[i];
   }
   return 0;
}
```
####2. 精度计算——乘法（大数乘小数）

语法：mult(char c[],char t[],int m);

```c++
  参数：
  c[]：被乘数，用字符串表示，位数不限
  t[]：结果，用字符串表示
  m：乘数，限定10以内
  返回值：null
  注意： 
   需要 string.h
  源程序：
```
```c++
 
       void mult(char c[],char t[],int m)
      {
          int i,l,k,flag,add=0;
          char s[100];
          l=strlen(c);
          for (i=0;i<l;i++)
              s[l-i-1]=c[i]-'0'; 
          for (i=0;i<l;i++)
                 {
                 k=s[i]*m+add;
                 if (k>=10) {s[i]=k%10;add=k/10;flag=1;} else 
      {s[i]=k;flag=0;add=0;}
                 }
          if (flag) {l=i+1;s[i]=add;} else l=i;
          for (i=0;i<l;i++)
              t[l-1-i]=s[i]+'0';
          t[l]='\0';
      }

```

####3. 精度计算——乘法（大数乘大数）

```
#include<iostream>  
#include<cstring>  
#include<algorithm>  
using namespace std;  
const int L=110;  
string mul(string a,string b)//高精度乘法a,b,均为非负整数  
{  
    string s;  
    int na[L],nb[L],nc[L],La=a.size(),Lb=b.size();//na存储被乘数，nb存储乘数，nc存储积  
    fill(na,na+L,0);fill(nb,nb+L,0);fill(nc,nc+L,0);//将na,nb,nc都置为0  
    for(int i=La-1;i>=0;i--) na[La-i]=a[i]-'0';//将字符串表示的大整形数转成i整形数组表示的大整形数  
    for(int i=Lb-1;i>=0;i--) nb[Lb-i]=b[i]-'0';  
    for(int i=1;i<=La;i++)  
        for(int j=1;j<=Lb;j++)  
        nc[i+j-1]+=na[i]*nb[j];//a的第i位乘以b的第j位为积的第i+j-1位（先不考虑进位）  
    for(int i=1;i<=La+Lb;i++)  
        nc[i+1]+=nc[i]/10,nc[i]%=10;//统一处理进位  
    if(nc[La+Lb]) s+=nc[La+Lb]+'0';//判断第i+j位上的数字是不是0  
    for(int i=La+Lb-1;i>=1;i--)  
        s+=nc[i]+'0';//将整形数组转成字符串  
    return s;  
}  
int main()  
{  
    string a,b;  
    while(cin>>a>>b) cout<<mul(a,b)<<endl;  
    return 0;  
}  

```

####4. 精度计算——除法 （大数除法包含取模）

```c++
#include<iostream>  
#include<cstring>  
#include<algorithm>  
using namespace std;  
const int L=110;  
int sub(int *a,int *b,int La,int Lb)  
{  
    if(La<Lb) return -1;//如果a小于b，则返回-1  
    if(La==Lb)  
    {  
        for(int i=La-1;i>=0;i--)  
            if(a[i]>b[i]) break;  
            else if(a[i]<b[i]) return -1;//如果a小于b，则返回-1  
  
    }  
    for(int i=0;i<La;i++)//高精度减法  
    {  
        a[i]-=b[i];  
        if(a[i]<0) a[i]+=10,a[i+1]--;  
    }  
    for(int i=La-1;i>=0;i--)  
        if(a[i]) return i+1;//返回差的位数  
    return 0;//返回差的位数  
  
}  
string div(string n1,string n2,int nn)//n1,n2是字符串表示的被除数，除数,nn是选择返回商还是余数  
{  
    string s,v;//s存商,v存余数  
     int a[L],b[L],r[L],La=n1.size(),Lb=n2.size(),i,tp=La;//a，b是整形数组表示被除数，除数，tp保存被除数的长度  
     fill(a,a+L,0);fill(b,b+L,0);fill(r,r+L,0);//数组元素都置为0  
     for(i=La-1;i>=0;i--) a[La-1-i]=n1[i]-'0';  
     for(i=Lb-1;i>=0;i--) b[Lb-1-i]=n2[i]-'0';  
     if(La<Lb || (La==Lb && n1<n2)) {  
            //cout<<0<<endl;  
     return n1;}//如果a<b,则商为0，余数为被除数  
     int t=La-Lb;//除被数和除数的位数之差  
     for(int i=La-1;i>=0;i--)//将除数扩大10^t倍  
        if(i>=t) b[i]=b[i-t];  
        else b[i]=0;  
     Lb=La;  
     for(int j=0;j<=t;j++)  
     {  
         int temp;  
         while((temp=sub(a,b+j,La,Lb-j))>=0)//如果被除数比除数大继续减  
         {  
             La=temp;  
             r[t-j]++;  
         }  
     }  
     for(i=0;i<L-10;i++) r[i+1]+=r[i]/10,r[i]%=10;//统一处理进位  
     while(!r[i]) i--;//将整形数组表示的商转化成字符串表示的  
     while(i>=0) s+=r[i--]+'0';  
     //cout<<s<<endl;  
     i=tp;  
     while(!a[i]) i--;//将整形数组表示的余数转化成字符串表示的</span>  
     while(i>=0) v+=a[i--]+'0';  
     if(v.empty()) v="0";  
     //cout<<v<<endl;  
     if(nn==1) return s;  
     if(nn==2) return v;  
}  
int main()  
{  
    string a,b;  
    while(cin>>a>>b) cout<<div(a,b,1)<<endl;  
    return 0;  
}  

```

####5. 精度计算——加法

```c++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int L=110;
string add(string a,string b)//只限两个非负整数相加
{
    string ans;
    int na[L]={0},nb[L]={0};
    int la=a.size(),lb=b.size();
    for(int i=0;i<la;i++) na[la-1-i]=a[i]-'0';
    for(int i=0;i<lb;i++) nb[lb-1-i]=b[i]-'0';
    int lmax=la>lb?la:lb;
    for(int i=0;i<lmax;i++) na[i]+=nb[i],na[i+1]+=na[i]/10,na[i]%=10;
    if(na[lmax]) lmax++;
    for(int i=lmax-1;i>=0;i--) ans+=na[i]+'0';
    return ans;
}
int main()
{
    string a,b;
    while(cin>>a>>b) cout<<add(a,b)<<endl;
    return 0;
}
```

####6. 精度计算——减法

```c++
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
#include <algorithm>
#include <cmath>
#define N 1001
using namespace std ;
int main ( )
{
    int a [ N ] , b [ N ] , c [ N ] , i ;
    char n [ N ] , n1 [ N ] , n2 [ N ] ;
    memset ( a , 0 , sizeof ( a ) ) ;
    memset ( b , 0 , sizeof ( b ) ) ;
    memset ( c , 0 , sizeof ( c ) ) ;
    gets ( n1 ) ;
    gets ( n2 ) ;
    int lena = strlen ( n1 ) , lenb = strlen ( n2 ) ;
    if ( lena < lenb || ( lena == lenb && strcmp ( n1 , n2 ) < 0 ) ) 
    //strcmp()为字符串比较函数，当n1=n2时，返回0，
    //n1>n2时，返回正整数；n1<n2时返回负整数
    //比完大小后，发现被减数小于减数，就交换。
    {
        strcpy ( n , n1 ) ;  //将n1数组的值完全赋值给n数组
        strcpy ( n1 , n2 ) ;
        strcpy ( n2 , n ) ;
        swap ( lena , lenb ) ;  //这步不能忘
        printf ( "-" ) ;  //别忘了输出负号
    }
    for ( i = 0 ; i < lena ; i ++ ) a [ lena - i ] = int ( n1 [ i ] - '0' ) ;
    for ( i = 0 ; i < lenb ; i ++ ) b [ lenb - i ] = int ( n2 [ i ] - '0' ) ;
    i = 1 ;
    while ( i <= lena || i<= lenb ) 
    {
        if ( a [ i ] < b [ i ] )   //借位
        {
            a [ i ] += 10 ;
            a [ i + 1 ] -- ;
        }
        c [ i ] = a [ i ] - b [ i ] ;
        i ++ ;
    }       
    int lenc = i ;
    while ( c [ lenc ] == 0 && lenc > 1 ) lenc -- ;    //最高位为0，则不输出
    for ( i = lenc ; i >= 1 ; i -- ) printf ( "%d" , c [ i ] ) ;     
    return 0 ;
}
```

####7. 高精度比较大小

```c++
#include<iostream>
#include<algorithm>
using namespace std;
main()
{
	string a,b;
	while(cin>>a>>b&&a!="0"&&b!="0")
	{
		bool check=true,same=true;
		int xa[1000]={},xb[1000]={};
		for(int i=0;i<a.length();i++)
			xa[i]=a[a.length()-i-1]-'0';
		for(int i=0;i<b.length();i++)
			xb[i]=b[b.length()-i-1]-'0';
		for(int i=max(a.length(),b.length());i>=0;i--)
		{
			if(xa[i]!=xb[i]) same=false;
			if(xa[i]<xb[i]) {check=false;break;}
			if(xa[i]>xb[i]) break;
		}
		if(same)
			cout<<"a==b"<<endl;
		else
			check?cout<<"a>b"<<endl:cout<<"a<b"<<endl;
	}
}
```

####8. 高精度乘单精度

```c++
#include<iostream>  
#include<cstring>  
#include<algorithm>  
using namespace std;  
const int L=100005;  
int na[L];  
string mul(string a,int b)//高精度a乘单精度b  
{  
    string ans;  
    int La=a.size();  
    fill(na,na+L,0);  
    for(int i=La-1;i>=0;i--) na[La-i-1]=a[i]-'0';  
    int w=0;  
    for(int i=0;i<La;i++) na[i]=na[i]*b+w,w=na[i]/10,na[i]=na[i]%10;  
    while(w) na[La++]=w%10,w/=10;  
    La--;  
    while(La>=0) ans+=na[La--]+'0';  
    return ans;  
}  
int main()  
{  
    string a;  
    int b;  
    while(cin>>a>>b) cout<<mul(a,b)<<endl;  
    return 0;  
}  

```

####9. 高精度除单精度

```c++
#include<iostream>  
#include<algorithm>  
using namespace std;  
string div(string a,int b)//高精度a除以单精度b  
{  
    string r,ans;  
    int d=0;  
    if(a=="0") return a;//特判  
    for(int i=0;i<a.size();i++)  
    {  
            r+=(d*10+a[i]-'0')/b+'0';//求出商  
            d=(d*10+(a[i]-'0'))%b;//求出余数  
    }  
    int p=0;  
    for(int i=0;i<r.size();i++)  
    if(r[i]!='0') {p=i;break;}  
    return r.substr(p);  
}  
int main()  
{  
    string a;  
    int b;  
    while(cin>>a>>b)  
    {  
        cout<<div(a,b)<<endl;  
    }  
    return 0;  
}  

```

####10. 高精度幂

```c++
#include <iostream>  
#include <cstdio>  
#include <algorithm>  
#include <cstring>  
#include <cmath>  
#include <map>  
#include <queue>  
#include <set>  
#include <vector>  
using namespace std;  
#define L(x) (1 << (x))  
const double PI = acos(-1.0);  
const int Maxn = 133015;  
double ax[Maxn], ay[Maxn], bx[Maxn], by[Maxn];  
char sa[Maxn/2],sb[Maxn/2];  
int sum[Maxn];  
int x1[Maxn],x2[Maxn];  
int revv(int x, int bits)  
{  
    int ret = 0;  
    for (int i = 0; i < bits; i++)  
    {  
        ret <<= 1;  
        ret |= x & 1;  
        x >>= 1;  
    }  
    return ret;  
}  
void fft(double * a, double * b, int n, bool rev)  
{  
    int bits = 0;  
    while (1 << bits < n) ++bits;  
    for (int i = 0; i < n; i++)  
    {  
        int j = revv(i, bits);  
        if (i < j)  
            swap(a[i], a[j]), swap(b[i], b[j]);  
    }  
    for (int len = 2; len <= n; len <<= 1)  
    {  
        int half = len >> 1;  
        double wmx = cos(2 * PI / len), wmy = sin(2 * PI / len);  
        if (rev) wmy = -wmy;  
        for (int i = 0; i < n; i += len)  
        {  
            double wx = 1, wy = 0;  
            for (int j = 0; j < half; j++)  
            {  
                double cx = a[i + j], cy = b[i + j];  
                double dx = a[i + j + half], dy = b[i + j + half];  
                double ex = dx * wx - dy * wy, ey = dx * wy + dy * wx;  
                a[i + j] = cx + ex, b[i + j] = cy + ey;  
                a[i + j + half] = cx - ex, b[i + j + half] = cy - ey;  
                double wnx = wx * wmx - wy * wmy, wny = wx * wmy + wy * wmx;  
                wx = wnx, wy = wny;  
            }  
        }  
    }  
    if (rev)  
    {  
        for (int i = 0; i < n; i++)  
            a[i] /= n, b[i] /= n;  
    }  
}  
int solve(int a[],int na,int b[],int nb,int ans[])  
{  
    int len = max(na, nb), ln;  
    for(ln=0; L(ln)<len; ++ln);  
    len=L(++ln);  
    for (int i = 0; i < len ; ++i)  
    {  
        if (i >= na) ax[i] = 0, ay[i] =0;  
        else ax[i] = a[i], ay[i] = 0;  
    }  
    fft(ax, ay, len, 0);  
    for (int i = 0; i < len; ++i)  
    {  
        if (i >= nb) bx[i] = 0, by[i] = 0;  
        else bx[i] = b[i], by[i] = 0;  
    }  
    fft(bx, by, len, 0);  
    for (int i = 0; i < len; ++i)  
    {  
        double cx = ax[i] * bx[i] - ay[i] * by[i];  
        double cy = ax[i] * by[i] + ay[i] * bx[i];  
        ax[i] = cx, ay[i] = cy;  
    }  
    fft(ax, ay, len, 1);  
    for (int i = 0; i < len; ++i)  
        ans[i] = (int)(ax[i] + 0.5);  
    return len;  
}  
string mul(string sa,string sb)  
{  
    int l1,l2,l;  
    int i;  
    string ans;  
    memset(sum, 0, sizeof(sum));  
    l1 = sa.size();  
    l2 = sb.size();  
    for(i = 0; i < l1; i++)  
        x1[i] = sa[l1 - i - 1]-'0';  
    for(i = 0; i < l2; i++)  
        x2[i] = sb[l2-i-1]-'0';  
    l = solve(x1, l1, x2, l2, sum);  
    for(i = 0; i<l || sum[i] >= 10; i++) // 进位  
    {  
        sum[i + 1] += sum[i] / 10;  
        sum[i] %= 10;  
    }  
    l = i;  
    while(sum[l] <= 0 && l>0)    l--; // 检索最高位  
    for(i = l; i >= 0; i--)    ans+=sum[i] + '0'; // 倒序输出  
    return ans;  
}  
string Pow(string a,int n)  
{  
    if(n==1) return a;  
    if(n&1) return mul(Pow(a,n-1),a);  
    string ans=Pow(a,n/2);  
    return mul(ans,ans);  
}  
int main()  
{  
    cin.sync_with_stdio(false);  
    string a;  
    int b;  
    while(cin>>a>>b) cout<<Pow(a,b)<<endl;  
    return 0;  
}  

```

####11. 任意进制转换

```c++
  进制的转换，用数组做了一个。 // 输入一个数 输入他的进制 转换为的进制 
 语法：conversion(char a[],char b[],int n,int m);
      参数：
      a[]：转换前的数字
      b[]：转换后的数字
      n：原进制数
      m：需要转换到的进制数
      返回值：null
      注意： 
       高于9的位数用大写'A'～'Z'表示，2～16位进制通过验证
      源程序： 
#include<iostream>
#include<cstring>
#include<cmath>
using namespace std;
void conversation(char a[],char b[],int n,int m)
{
    int num=0,i,j,t;
	char c;
    int p=strlen(a)-1;
	for(i=0;a[i]!='\0';i++)
	{
	    if(a[i]>='0'&&a[i]<='9')
		{
		   t=a[i]-'0';
		}
		else
		{
		    t=a[i]-'A'+10; 
		}
	//	num=num*n+t;//这个和num+=t*pow(n,p);的效果是一样的，开始我用的是这个。
		num+=t*pow(n,p);//为了方便你们理解，我还是换成了这个
		--p;
	}
//	cout<<num<<endl;
	i=0;
	while(1)
	{
	 if(num==0)break;
	  t=num%m;
	  if(t<=9)
	  b[i]=t+'0';
	  else
	  b[i]=t+'A'-10; 
	  num/=m;
	  i++;
	}
	for(j=i-1;j>=0;j--)
		cout<<b[j];
	for(j=0;j<=i/2;j++)
	{
	   c=b[j];
	   b[j]=b[i-j];
	   b[i-j]=c;
	}
	b[i+1]='\0';
		cout<<endl;

}
int main()
{
	char a[100],b[100];
	int n,m;
   while(cin>>a>>n>>m)
   {
	conversation(a,b,n,m);
	for(int i=1;b[i]!='\0';i++)
		cout<<b[i];
	cout<<endl;
   }
	return 0;
}

```

####12. 最大公约数，最小公倍数

```c++
最大公约数:
int hcf(int a, int b){
return b == 0 ? a : hcf(b, a % b);
}
最小公倍数：
lcd = a / hcf（a，b）* b； 
```

####13. 求排列组合数

```c++
 语法：result=P(long n,long m); / result=long C(long n,long m);
      参数：
      m：排列组合的上系数
      n：排列组合的下系数
      返回值：排列组合数
      注意： 
       符合数学规则：m<＝n
      源程序： 
       long P(long n,long m)
      {
          long p=1;
          while(m!=0)
              {p*=n;n--;m--;}
          return p;
      } 
      long C(long n,long m)
      {
          long i,c=1;
          i=m;
          while(i!=0)
              {c*=n;n--;i--;}
          while(m!=0)
              {c/=m;m--;}
          return c;
      } 

```

####14. 全排列

```c++
语法: void qp(int Array[],int begin,int end);
注意:当参与全排列的数字稍大的时候将会有很大的计算量

#include<iostream>
using namespace std;
const int MaxNum=20;
static int a[MaxNum];
void qp(int Array[],int begin,int end);
int main()
{
	int i;
	for(i=0;i<MaxNum;i++)
		a[i]=i+1;	
	//初始化数组为:1,2,3..
	qp(a,0,10);
	return 0;
}
void qp(int Array[],int begin,int end)
{
	int i;
	if(begin>=end)
	{
		for(i=0;i<end;i++)
			cout<<Array[i]<<"\t";
		cout<<endl;
	}
	else for(i=begin;i<end;i++)
	{
		swap(a[begin],a[i]);
		qp(a,begin+1,end);
		swap(a[begin],a[i]);	
	}
}
//stl里面的全排列生成函数next_permutation
#include<iostream>
#include <algorithm>
using namespace std;

int main()
{
	int i;
	int A[] = {0,1,2,3};
	while(next_permutation(A, A+4)==true)	//prev_permutation(A, A+4);

	{
		for(i=0;i<4;i++)
			cout<<A[i]<<"\t";
		cout<<endl;

	}
}

```

```c++
#include<iostream>
#include<algorithm>
using namespace std;
int main(){
string str="abc";
while(next_permutation(str.begin(),str.end()))
cout<<str<<endl;
return 0;
}
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
int main(){
vector<int> dp;
dp.push_back(1);
dp.push_back(2);
dp.push_back(3);
while(next_permutation(dp.begin(),dp.end())){
cout<<dp[0]<<dp[1]<<dp[2]<<endl;
}
return 0;
}
```



