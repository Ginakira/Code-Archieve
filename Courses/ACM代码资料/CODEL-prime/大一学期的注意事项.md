### 大一时期的简要学习方法

### 基础部分的学习方法

#### 1．学习相关的基础知识

##### a.  基础语法部分

##### b.  库函数的了解

例如　math库里面有什么函数，缺什么函数，string里有那些好用的函数等等。

##### c. 计算机相关基础

例如：如int的最大值是多少，指针占多少字节，位运算的运算机制，计算机数据存储方式大端小端等等。

##### d. 学习要做笔记

**Typora**: 是一款由Abner Lee开发的轻量级[Markdown]编辑器，适用OS X、Windows和Linux三种操作系统，是一款免费软件。采用所见即所得的编辑方式，实现了即时预览的功能，但也可切换至源代码编辑模式。你可以查询相关的使用方式。比如用Latex写数学公式，做个表格，写个代码段之类的。

基础语法

```
#       一级标题    
##      二级标题    
###     三级标题    
####    四级标题    
#####   五级标题    
######  六级标题 

> 引用内容1
> 引用内容2
>> 引用内容3
```

　多行代码语法

```
~~~
​```
~~~java
​```c
```

无序表

```
* 无序列表1
+ 无序列表2
- 无序列表3
```

表格

```
|姓名|性别|年龄|手机号|
|:---|:--:|:--:|---:|
|张三|男|21|18975346876|
|李四|女|23|17789548964|
|王五|男|25|15876513546|
```

数学表达式等等。。

### 例如对指针部分做个笔记：

#### 打印指针的值：

```c
%x 显示16进制数
%o 显示8进制数
%p 将值显示成实现的专用格式，通常是16进制的数
```

#### 虚拟内存和指针

```
让打印地址变得更为复杂的是，在虚拟操作系统上显示的指针地址一般不是真实的物理内存地址。虚拟操作系统允许程序分布在机器的物理地址空间上。应用程序分为页（或帧），这些页表示内存中的区域。应用程序的页被分配在不同的（可能是不相邻的）内存区域上，而且可能不是同时处于内存中。如果操作系统需要占用被某一页占据的内存，可以将这些内存交换到二级存储器中，待将来需要时再装载进内存中（内存地址一般都会与之前的不同）。这种能力为虚拟操作系统管理内存提供了相当大的灵活性。

每个程序使用的地址是虚拟地址，操作系统会在需要时将虚拟地址映射成物理地址。

我们在查看指针内容时看到的地址，操作系统会将虚拟地址映射成真实地址。
```

关于这一块，可以查看[物理内存与虚拟内存之间的映射](https://blog.csdn.net/zhyfxy/article/details/70157248)，配合理解。

#### null的概念:

```
null概念：  通过null指针常量来支持的一种抽象
null指针常量　
NULL宏： #define NULL ((void *)0)
ASCII字符串NUL： 全是0的字节
null字符串： 不包含任何字符的空串
null语句：  只有一个分号的语句
```

#### void指针：

```c
void指针具有和char相同的形式和内存对其方式
void指针和别的指针永远不会相等， 但是， 两个赋值为NULL的void指针是相等的

任何指针都能被赋值给void指针， 他可以转化为原来的类型。
int a;
int *p = &a;
void *pv = p;
p = *pv;
他们（两次的p）的值是相等的
```

#### 内存模型：

```
64位机器上的不同数据分配在内存长度上差异变得明显，这和操作系统以及编译器有关。
```

#### 指针的预定义类型：

```c
size_t 用于安全的表示长度
ptrdiff_t  用于处理指针算术运算
intptr_t uintptr_t  用于储存指针地址

size_t :
头文件：stdio.h stblib.h
#ifndef _SIZE_T
#define _SIZE_T
typedef unsigned int size_t;
#endif
32位机器上，他的长度是32,64位机器上，他的长度是64。
int main(){
    size_t a = -0x7fffffff;
    printf("%d\n", a);
    printf("%u\n", a);
    printf("%lu\n", a);
    printf("%zu\n", a);
    return 0;
}
printf：
-2147483647
2147483649
18446744071562067969
18446744071562067969

size_t本来是打印正整数，打印负数会出现问题。
size_t用作sizeof的返回值类型，包括malloc和strlen等许多函数的类型。


```

#### 常量与指针：

##### 1.指向常量的指针 

可以将指针定义为指向常量，这意味着不能通过指针修改它所引用的值.

```C
int num = 10;
int *p;            指向int型的指针      
const int kk = 0;
const int *pci;    指向int型或者const int型的指针

1.pci可以被修饰为指向不同的整数常量
2.pci可以被修改为
3.可以解引pci以读取数据。
4.不可以解引pci从而修改指向它的数据。

数据类型和const关键字的顺序不重要。下面两个语句是等价的：
const int *pci;
int const *pci;
```



##### 2.指向非常量的常量指针

+ 指针指向的数据可以被修改 （这种指针对常量值进行操作）
+ 指针必须被初始化为指向非常量的变量
+ 指针不能被修改

cpi指针指向的数据可以被修改：

```c 
int main () {
    int num = 100;
    int *const cpi = &num;
    printf("num = %d\n", num);
    printf("&cpi = %p, cpi = %p, *cpi = %d\n", &cpi, cpi, *cpi);
    
    *cpi = 25;
    printf("num = %d\n", num);
    printf("&cpi = %p, cpi = %p, *cpi = %d\n", &cpi, cpi, *cpi);

    return 0;
}
```

cpi必须被初始化为指向非常量的变量：

cpi不能被修改：

​                                 

##### 3.指向常量的常量指针

这种指针本身不能被修改，它指向的数据也不能通过它来修改。

对于这种指针：

+ 我们不能修改指针

+ 我们不能修改指针指向的数据

  

如果给指针cpci一个新地址

如果让指针cpci解引一个指针并且赋新值 

##### 4.指向 “指向常量的常量指针”的指针

指向常量的指针也可以有多层间接引用。

| 指针类型             | 指针是否可修改 | 指向指针打数据是否可修改 |
| -------------------- | -------------- | ------------------------ |
| 指向非常量的指针     | 是             | 是                       |
| 指向常量的指针       | 是             | 否                       |
| 指向非常量的常量指针 | 否             | 是                       |
| 指向常量的常量指针   | 否             | 否                       |







### 2.算法部分 

### 一些基本算法和数据结构

##### 例如　：队列 栈 树 图 并查集 堆 DFS BFS 最短路 最小生成树 拓扑排序 动态规划 贪心 搜索 哈希 Trie 快速幂 逆元 费马小定理 欧拉函数 素数筛 分解质因数等，这是基础操作

#### a.  时间复杂度和空间复杂度的计算

代码一个for循环是多少时间，一段数组占了多少空间，用了多少循环，开辟了多少数组等。

#### b. 做题中的基本错误

```
Wrong Answer： 有自己没有注意到的细节，或者方法错了。
TLE： 运行时间超过给出时间
CE：编译错误
RE：有时候会stack overflow(爆栈)，access violation（指针非法访问，访问越界）之类的
```

### c. 循环渐进的学习

##### 例如：最初学了基础二分，BFS、DFS，最迟学算法可能只能循规蹈矩的改模版，当时并不懂栈（stack）和队列（queue），每次都要纠结一下是FIFO还是FILO。像BFS、DFS这种东西，最后发现完全就是算法思想，都不用模板了。

**但是一定要多做题！这是巩固学习知识的方法！**

 

 ###  3.关键部分

##### 1 ．最关键还是做题：基础的内容学会用模板，大概知道模板每一步在干什么，达到了解的程度。一部分内容要掌握原理。当你产生了学习吃力，跟不上周围小伙伴的脚步的感觉时，你欠缺的只是一个量而，有人吸收的快，走的就快，　但是这是能用量来补，不管你的天赋强弱，多做题吧，当达到量的高度以后自然会有质的飞跃。

##### 觉得没有动力的时候，想想自己的目标，大家都喝了无数碗的鸡汤，咱们再干一碗。 

##### ２．持之以恒的学习：我们计算机的这条路，注定不是轻松的，想要有收获，必须要加强练习和学习。没有轻松就能得到的成绩。

##### ３．明确你的对手：你的对手不是你周围的同学伙伴 ，而是外面那些拼搏的其他同龄同学，在现在这个情况下，你们几乎不知道他们是什么样的，他们经历过什么，他们学习状态是什么样。　

##### 但是等收获的时候，等你们感受到差距的时候，那就晚了。



