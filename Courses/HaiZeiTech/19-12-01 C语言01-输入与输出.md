# 2019-12-1 C语言 01 - 输入与输出

## printf函数

原型：

```cpp
int printf(const char *format, ...)
```

- `format` 格式控制字符串
- `...` 可选参数
- `int` 返回成功输出的字符个数

Practice 1 - 输出读入的10进制数的位数

```cpp
#include <cstdio>
#include <iostream>
using namespace std;

int main() {
    int number, digit;
    scanf("%d", &number); 				//输入123456
    digit = printf("%d", number);
    printf("%d\n", digit);			//输出6，代表成功打印了6个字符
    return 0;
}
```



### sprintf()

`sprintf()`的作用是将输出结果保存到字符串，如将4个数字转换为ipv4地址的形式：

```c
int main() {
    int a, b, c, d;
    char ipv[233];
    scanf("%d%d%d%d", &a, &b, &c, &d);				//输入192 168 2 48
    sprintf(ipv, "%d.%d.%d.%d", a, b, c, d);	
    printf("%s", ipv);												//输出192.168.2.48
    return 0;
}
```



### fprintf()

`fprintf()`的作用是将输出结果保存到指定文件中，如我们将上一个例子中的内容保存到out文件中：

```c
int main() {
    int a, b, c, d;
    char ipv[233];
    scanf("%d%d%d%d", &a, &b, &c, &d);
    sprintf(ipv, "%d.%d.%d.%d", a, b, c, d);
    printf("%s", ipv);
    FILE *fd = fopen("out", "wb");
    fprintf(fd, "%s", ipv);
    return 0;
}
```

此时我们就已经将字符串ipv中的内容保存到了out文件中。其中fd为文件指针，wb为以二进制模式写入。fprintf函数的第一个参数也可以替换为其他流，如stdin、stdout、stderr。

> Tips: 可以使用重定向操作，将标准输出流的输出结果保存到指定文件中（不包含stderr和其他流的内容）。
>
> 如： `./a.out > output.txt` 
>
> 而使用`2>`时，则只将stderr的内容输出到文件中，如：`./a.out 2> output.txt`

## scanf函数

原型：

```cpp
int scanf(const char *format, ...)
```

- `format` 格式控制字符串
- `...` 可选参数
- `int` 返回成功读入的参数个数

Exmaple：

```cpp
#include <cstdio>
#include <iostream>
using namespace std;

int main() {
    int number, digit;
    digit = scanf("%d", &number); 				//输入123456
    printf("\n%d\n", digit);			//输出1，代表成功读入了1个参数
    return 0;
}
```

Practice 2 - 读入一行可能包含空格的字符串并输出其字符个数

```c
#include <stdio.h>

int main() {
    char str[233];
    scanf("%[^\n]s", str);
    printf(" has %d digits", printf("%s", str));
    return 0;
}
```

知识点：格式化字符串 / 逗号表达式的执行顺序

`[^\n]` 字符匹配集，只读入/输出匹配集中的内容，遇到不匹配立即停止读入/输出

但如果我们循环读入：

```c
#include<stdio.h>

int main() {
    char str[233];
    while(scanf("%[^\n]s", str) != EOF) {
        printf(" has %d digits\n", printf("%s", str));
    }
    return 0;
}
```

会发现程序将死循环输出，每次都输出同样的内容。

其原因是，在scanf通过`[^\n]`进行匹配时，当我们输入完回车时，scanf将匹配到这个回车并且因不符合字符匹配集中的内容读入停止。因为scnaf为流式输入，所以执行下次while时，scanf将匹配到这个上次未被读入的换行，造成死循环。此时如果我们输出一下scanf的返回值，会发现除了第一次是1外，死循环后的返回值都为0，表示成功读入了0个参数，但此时仍然满足不等于EOF的条件（EOF = -1）。改进如下：

```c
#include<stdio.h>

int main() {
    char str[233];
    while(scanf("%[^\n]s", str) != EOF) {
        getchar();
        printf(" has %d digits\n", printf("%s", str));
    }
    return 0;
}
```

使用`getchar()`吸收掉多余的空格后，程序运行效果满足预期。